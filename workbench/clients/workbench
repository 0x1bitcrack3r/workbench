#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Workbench CLI using IPython Interactive Shell"""
import os, sys
import hashlib
import zerorpc
import tabulate
import workbench.clients.workbench_client as workbench_client
import IPython
import functools


class my_transformer(IPython.core.prefilter.PrefilterTransformer):
    def transform(self, line, continue_prompt):
        skip_it = ['"',"\"",'(',')']
        if line.startswith('help ') and not any([skip in line for skip in skip_it]):
            return ','+line
        elif line.startswith('load_sample '):
            return ','+line
        else:
            return line

# These little helpers get around IPython wanting to take the
# __repr__ of string output instead of __str__.
class repr_to_str(str):
    def __repr__(self):
        return str(self)

def repr_to_str_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return repr_to_str(func(*args, **kwargs))
    return wrapper    

    
class Session(object):
    """Store information specific to the user session"""
    def __init__(self):
        """Initialization of Session object"""
        self.filename = '-'
        self.md5 = '-'
        self.short_md5 = '-'
        self.server = 'localhost'

class WorkbenchCLI(object):
    """Workbench CLI using IPython Interactive Shell"""

    def __init__(self):
        ''' Workbench CLI Initialization '''

        # Grab server arguments
        server_info = workbench_client.grab_server_args()

        # Spin up workbench server
        self.workbench = zerorpc.Client(timeout=300, heartbeat=60)
        self.workbench.connect('tcp://'+server_info['server']+':'+server_info['port'])

        # Create a user session
        self.session = Session()
        # {'filename': '-', 'md5': '-', 'short_md5': '-', 'server': 'localhost'}

        # We have a namespace dictionariy for our Interactive Shell
        self.namespace = self.make_namespace()

        # Our Interactive IPython shell
        self.ipshell = None
 

    def try_get_tables(self, data):
        ''' Try to determine if this data has table keys '''

        table_list = []
        if 'tables' in data.keys():
            for table in data['tables']:
                if isinstance(data[table], list):
                    table_list.append(table)

        # At this point the list has data in it or is an empty list
        return table_list

    def table_xform(self, table, force_to_str=False):
        ''' Transform a table from a list of dicts to dict of lists'''
        import collections

        new_table = collections.defaultdict(list)
        for row in table:
            for key, value in row.items():
                if force_to_str:
                    new_table[key].append(str(value)[:40])
                elif isinstance(value, str):
                    new_table[key].append(value[:40])
                else:
                    new_table[key].append(value)
        return new_table

    def print_table(self, table):
        ''' Print the table using tabulate '''
        try:
            print(tabulate.tabulate(table_xform(table), headers="keys"))
        except TypeError:
            print(tabulate.tabulate(table_xform(table, force_to_str=True), headers="keys"))

    def load_sample(self, file_path):
        """Load a sample (or samples) into workbench
           load_sample </path/to/file_or_dir> """

        # Do they want everything under a directory?
        if os.path.isdir(file_path):
            file_list = [os.path.join(file_path, child) for child in os.listdir(file_path)]
        else:
            file_list = [file_path]

        # Upload the files into workbench
        for path in file_list:
            with open(path, 'rb') as my_file:
                raw_bytes = my_file.read()
                md5 = hashlib.md5(raw_bytes).hexdigest()
                if not self.workbench.has_sample(md5):
                    print('Storing Sample...')
                    basename = os.path.basename(path)
                    md5 = self.workbench.store_sample(basename, raw_bytes, 'unknown')
                else:
                    print('Sample already in Workbench...')

                # Store information about the sample into the sesssion
                basename = os.path.basename(path)
                self.session.filename = basename
                self.session.md5 = md5
                self.session.short_md5 = md5[:6]
                self.ipshell.push({'short_md5': self.session.short_md5})

    def work_request(self, worker, md5=None):
        """Wrapper for a work_request to workbench"""
        if not md5 and not self.session.md5:
            return 'Must call worker with an md5 argument...'
    
        # Set the md5 to the session md5
        md5 = self.session.md5

        # Make the work_request with worker and md5 args
        return self.workbench.work_request(worker, md5)

    def make_namespace(self):
        """Create a customized namespace for Workbench with a bunch of shortcuts
            and helper/alias functions that will make using the shell MUCH easier.
        """
        
        # First add all the workers
        commands = {}
        for worker in self.workbench.list_all_workers():
            commands[worker] = lambda *args: self.work_request(worker, *args)

        # Now the general commands which are often overloads
        # for some of the workbench commands
        general = {
            'workbench': self.workbench,
            'help': repr_to_str_decorator(self.workbench.help), 
            'load_sample': self.load_sample,
            'short_md5': self.session.short_md5
        }
        commands.update(general)

        # Return the list of workbench commands
        return commands

    def run(self):
        ''' Running the workbench CLI '''

        # Announce Version
        print(self.workbench.help('version'))

        # Now that we have the Workbench connection spun up, we register some stuff 
        # with the embedded IPython interpreter and than spin it up
        cfg = IPython.config.loader.Config()
        cfg.InteractiveShellEmbed.autocall = 2
        cfg.InteractiveShellEmbed.colors = 'Linux'
        cfg.InteractiveShellEmbed.color_info = True
        cfg.InteractiveShellEmbed.autoindent = False
        cfg.InteractiveShellEmbed.deep_reload = True
        cfg.PromptManager.in_template = (
            '{color.Purple}'
            '{short_md5}'
            '{color.LightGray} Workbench{color.Green}[\#]> ')
        cfg.PromptManager.out_template = ''

        # Create the IPython shell
        self.ipshell = IPython.terminal.embed.InteractiveShellEmbed(
            config=cfg, banner1=self.workbench.help('workbench'), exit_msg='\nWorkbench has SuperCowPowers...')

        # Register our transformer
        transformer = my_transformer(self.ipshell, self.ipshell.prefilter_manager) 

        # Start up the shell with our namespace
        self.ipshell(local_ns=self.namespace)


if __name__ == '__main__':

    cli = WorkbenchCLI()
    cli.run()
